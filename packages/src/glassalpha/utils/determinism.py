"""Determinism enforcement for byte-identical reproducibility.

This module provides comprehensive determinism enforcement to ensure
byte-identical outputs across runs and platforms. It addresses:

1. Random number generator seeding (Python, NumPy, ML frameworks)
2. BLAS/LAPACK threading (OpenBLAS, MKL, OpenMP)
3. PDF metadata normalization (timestamps, font order)
4. Platform-specific behavior (sorting, hashing, floating-point)

Usage:
    with deterministic(seed=42):
        # All operations are deterministic
        audit_results = run_audit(config)
        pdf = generate_report(audit_results)
"""

import hashlib
import logging
import os
import random
from collections.abc import Generator
from contextlib import contextmanager
from pathlib import Path
from typing import Any

import numpy as np

from glassalpha.utils.seeds import set_global_seed

logger = logging.getLogger(__name__)


@contextmanager
def deterministic(seed: int, *, strict: bool = True) -> Generator[None, None, None]:
    """Context manager for deterministic execution.

    This enforces comprehensive determinism across:
    - Random number generators (Python, NumPy, optional frameworks)
    - BLAS threading (OpenBLAS, MKL, BLIS, OpenMP)
    - Hash randomization (PYTHONHASHSEED)
    - NumExpr parallelism

    Args:
        seed: Master seed for all randomness
        strict: If True, enforce single-threaded BLAS/LAPACK

    Yields:
        Context with deterministic environment

    Example:
        >>> with deterministic(seed=42):
        ...     results = run_audit(config)
        >>> # Results are byte-identical across runs

    Raises:
        RuntimeError: If critical environment variables cannot be set

    """
    # Save original environment
    original_env = {
        "PYTHONHASHSEED": os.environ.get("PYTHONHASHSEED"),
        "OMP_NUM_THREADS": os.environ.get("OMP_NUM_THREADS"),
        "OPENBLAS_NUM_THREADS": os.environ.get("OPENBLAS_NUM_THREADS"),
        "MKL_NUM_THREADS": os.environ.get("MKL_NUM_THREADS"),
        "BLIS_NUM_THREADS": os.environ.get("BLIS_NUM_THREADS"),
        "NUMEXPR_NUM_THREADS": os.environ.get("NUMEXPR_NUM_THREADS"),
    }

    # Save original random states
    original_random_state = random.getstate()
    original_numpy_state = np.random.get_state()

    try:
        # Set environment variables for determinism
        os.environ["PYTHONHASHSEED"] = str(seed)

        if strict:
            # Force single-threaded BLAS/LAPACK for determinism
            # These must be set before numpy/scipy imports, but we set them anyway
            os.environ["OMP_NUM_THREADS"] = "1"
            os.environ["OPENBLAS_NUM_THREADS"] = "1"
            os.environ["MKL_NUM_THREADS"] = "1"
            os.environ["BLIS_NUM_THREADS"] = "1"
            os.environ["NUMEXPR_NUM_THREADS"] = "1"

            logger.debug("Enforcing single-threaded BLAS/LAPACK for determinism")

        # Set all random seeds using centralized seed manager
        set_global_seed(seed)

        # Additional NumPy settings for determinism
        _enforce_numpy_determinism()

        logger.info(f"Deterministic context enabled with seed={seed}, strict={strict}")

        yield

    finally:
        # Restore original environment
        for key, value in original_env.items():
            if value is None:
                os.environ.pop(key, None)
            else:
                os.environ[key] = value

        # Restore random states
        random.setstate(original_random_state)
        np.random.set_state(original_numpy_state)

        logger.debug("Restored original random states and environment")


def _enforce_numpy_determinism() -> None:
    """Enforce NumPy-specific determinism settings."""
    # Set NumPy error handling to consistent mode
    np.seterr(all="warn")

    # Disable NumPy's implicit threading for consistent behavior
    # Note: This only affects numpy, not underlying BLAS
    try:
        # NumPy 2.0+ uses different API
        if hasattr(np, "set_num_threads"):
            np.set_num_threads(1)  # type: ignore[attr-defined]
    except Exception as e:  # noqa: BLE001
        logger.debug(f"Could not set NumPy threads: {e}")


def normalize_pdf_metadata(
    pdf_path: Path | str,
    *,
    fixed_timestamp: str = "2025-01-01T00:00:00Z",
    producer: str = "GlassAlpha/1.0",
    creator: str = "GlassAlpha",
) -> None:
    """Normalize PDF metadata for byte-identical reproducibility.

    This removes or fixes non-deterministic metadata:
    - CreationDate and ModDate (timestamps)
    - Producer string (may include version info)
    - Creator string
    - DocumentID (random UUID in some generators)

    Args:
        pdf_path: Path to PDF file to normalize
        fixed_timestamp: ISO8601 timestamp to use for dates
        producer: Fixed producer string
        creator: Fixed creator string

    Note:
        This modifies the PDF in-place. Make a backup if needed.
        Currently supports PDFs generated by WeasyPrint/Cairo.

    Raises:
        FileNotFoundError: If PDF file doesn't exist
        ValueError: If PDF format is not recognized

    """
    pdf_path = Path(pdf_path)

    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")

    # Read PDF content
    content = pdf_path.read_bytes()

    # Normalize metadata using pattern matching
    # This is a simple approach for WeasyPrint PDFs
    # For production, consider using pypdf or similar

    # Convert timestamp to PDF date format
    # PDF date format: D:YYYYMMDDHHmmSS
    from datetime import datetime

    dt = datetime.fromisoformat(fixed_timestamp.replace("Z", "+00:00"))
    pdf_date = dt.strftime("D:%Y%m%d%H%M%S")

    # For now, just log - full implementation requires PDF library
    # TODO: Implement full PDF metadata normalization using pypdf or similar
    logger.warning(
        f"PDF metadata normalization not fully implemented. "
        f"For production use, integrate pypdf or similar library. "
        f"PDF: {pdf_path}",
    )

    # Placeholder for future implementation
    # Will use pypdf to properly parse and rewrite metadata
    _ = pdf_date  # Silence unused variable warning
    _ = producer
    _ = creator
    _ = content


def compute_file_hash(file_path: Path | str, algorithm: str = "sha256") -> str:
    """Compute cryptographic hash of file for verification.

    Args:
        file_path: Path to file to hash
        algorithm: Hash algorithm ('sha256', 'sha512', 'md5')

    Returns:
        Hexadecimal hash digest

    Raises:
        FileNotFoundError: If file doesn't exist
        ValueError: If algorithm is not supported

    """
    file_path = Path(file_path)

    if not file_path.exists():
        raise FileNotFoundError(f"File not found: {file_path}")

    # Get hash function
    try:
        hash_func = hashlib.new(algorithm)
    except ValueError as e:
        raise ValueError(f"Unsupported hash algorithm: {algorithm}") from e

    # Read and hash file in chunks for memory efficiency
    with file_path.open("rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            hash_func.update(chunk)

    return hash_func.hexdigest()


def verify_deterministic_output(
    path1: Path | str,
    path2: Path | str,
    *,
    algorithm: str = "sha256",
) -> tuple[bool, str, str]:
    """Verify two files are byte-identical.

    Args:
        path1: First file path
        path2: Second file path
        algorithm: Hash algorithm to use

    Returns:
        Tuple of (are_identical, hash1, hash2)

    """
    hash1 = compute_file_hash(path1, algorithm=algorithm)
    hash2 = compute_file_hash(path2, algorithm=algorithm)

    return (hash1 == hash2, hash1, hash2)


def validate_deterministic_environment(*, strict: bool = False) -> dict[str, Any]:
    """Validate environment for deterministic execution.

    Args:
        strict: If True, fail on any non-deterministic settings

    Returns:
        Validation results with warnings and errors

    Raises:
        RuntimeError: If strict=True and critical issues found

    """
    results: dict[str, Any] = {
        "status": "pass",
        "warnings": [],
        "errors": [],
        "checks": {},
    }

    # Check PYTHONHASHSEED
    hashseed = os.environ.get("PYTHONHASHSEED")
    if hashseed is None or hashseed == "random":
        msg = "PYTHONHASHSEED not set or random - hash ordering non-deterministic"
        results["warnings"].append(msg)
        results["checks"]["pythonhashseed"] = False
    else:
        results["checks"]["pythonhashseed"] = True

    # Check BLAS threading
    threading_vars = ["OMP_NUM_THREADS", "OPENBLAS_NUM_THREADS", "MKL_NUM_THREADS"]
    for var in threading_vars:
        value = os.environ.get(var)
        if value is None:
            msg = f"{var} not set - BLAS may use multiple threads (non-deterministic)"
            results["warnings"].append(msg)
            results["checks"][var.lower()] = False
        elif value != "1":
            msg = f"{var}={value} - BLAS threading enabled (may be non-deterministic)"
            results["warnings"].append(msg)
            results["checks"][var.lower()] = False
        else:
            results["checks"][var.lower()] = True

    # Update status
    if results["errors"]:
        results["status"] = "fail"
    elif results["warnings"]:
        results["status"] = "warning"

    # Strict mode enforcement
    if strict and (results["errors"] or results["warnings"]):
        raise RuntimeError(
            f"Deterministic environment validation failed in strict mode:\n"
            f"Errors: {results['errors']}\n"
            f"Warnings: {results['warnings']}",
        )

    return results
