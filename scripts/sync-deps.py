#!/usr/bin/env python3
"""Synchronize development dependencies across all environments.

This script ensures that:
1. Local venv matches requirements.txt
2. CI uses the same versions
3. Contributors get consistent environments
4. Constraints files are up to date

Usage:
    python scripts/sync-deps.py --check    # Check if environments are in sync
    python scripts/sync-deps.py --sync     # Update local environment
    python scripts/sync-deps.py --freeze   # Freeze current versions to constraints
"""

import argparse
import subprocess
import sys
from pathlib import Path


def get_project_root() -> Path:
    """Get the project root directory."""
    return Path(__file__).parent.parent


def check_venv_exists() -> bool:
    """Check if .venv directory exists."""
    venv_path = get_project_root() / ".venv"
    return venv_path.exists()


def check_editable_install() -> bool:
    """Check if package is installed in editable mode."""
    try:
        result = subprocess.run(
            [".venv/bin/python3", "-c", "import glassalpha; print(glassalpha.__file__)"],
            capture_output=True,
            text=True,
            check=False,
            cwd=get_project_root(),
        )
        if result.returncode != 0:
            return False

        # If package is in site-packages, it's not editable
        is_editable = "site-packages" not in result.stdout
        return is_editable
    except Exception:
        return False


def check_sync() -> bool:
    """Check if environment is in sync."""
    print("üîç Checking environment synchronization...")
    print()

    issues = []

    # Check 1: Virtual environment exists
    if not check_venv_exists():
        print("‚ùå Virtual environment not found at .venv/")
        issues.append("missing_venv")
    else:
        print("‚úì Virtual environment exists")

    # Check 2: Package installed in editable mode
    if not check_editable_install():
        print("‚ùå Package not installed in editable mode")
        issues.append("not_editable")
    else:
        print("‚úì Package installed in editable mode")

    # Check 3: Requirements match (simplified check)
    # TODO: Compare installed versions with requirements.txt

    print()
    if issues:
        print("‚ùå Environment is NOT in sync")
        print()
        print("Fix with:")
        if "missing_venv" in issues:
            print("  python3 -m venv .venv")
        if "not_editable" in issues or "missing_venv" in issues:
            print('  .venv/bin/pip install -e ".[dev,all]"')
        return False
    print("‚úÖ Environment is in sync")
    return True


def sync_environment() -> bool:
    """Synchronize the local environment."""
    print("üîÑ Synchronizing environment...")
    print()

    root = get_project_root()

    # Ensure venv exists
    if not check_venv_exists():
        print("üì¶ Creating virtual environment...")
        result = subprocess.run(
            ["python3", "-m", "venv", ".venv"],
            cwd=root,
            check=False,
        )
        if result.returncode != 0:
            print("‚ùå Failed to create virtual environment")
            return False
        print("‚úì Virtual environment created")

    # Install in editable mode
    print("üì• Installing package in editable mode...")
    result = subprocess.run(
        [".venv/bin/pip", "install", "-e", ".[dev,all]"],
        cwd=root,
        check=False,
    )
    if result.returncode != 0:
        print("‚ùå Failed to install package")
        return False

    print()
    print("‚úÖ Environment synchronized")
    return True


def freeze_constraints() -> bool:
    """Freeze current versions to constraints file."""
    print("üßä Freezing dependencies...")
    print()

    root = get_project_root()

    if not check_venv_exists():
        print("‚ùå Virtual environment not found - cannot freeze")
        return False

    # Get pip freeze output
    result = subprocess.run(
        [".venv/bin/pip", "freeze", "--exclude-editable"],
        capture_output=True,
        text=True,
        cwd=root,
        check=False,
    )

    if result.returncode != 0:
        print("‚ùå Failed to freeze dependencies")
        return False

    # Write to constraints file
    constraints_file = root / "constraints" / "dev-requirements.txt"
    constraints_file.parent.mkdir(exist_ok=True)

    with open(constraints_file, "w") as f:
        f.write("# Auto-generated by scripts/sync-deps.py\n")
        f.write("# DO NOT EDIT MANUALLY - regenerate with: make freeze-deps\n")
        f.write(f"# Generated from: {check_venv_exists()}\n")
        f.write("\n")
        f.write(result.stdout)

    print(f"‚úì Frozen dependencies to {constraints_file}")
    print()
    print("‚úÖ Dependencies frozen")
    print()
    print("Next steps:")
    print("  1. Review the changes: git diff constraints/dev-requirements.txt")
    print("  2. Commit if needed: git add constraints/dev-requirements.txt")
    return True


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Synchronize development dependencies")
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check if environment is in sync",
    )
    parser.add_argument(
        "--sync",
        action="store_true",
        help="Synchronize local environment",
    )
    parser.add_argument(
        "--freeze",
        action="store_true",
        help="Freeze current versions to constraints file",
    )

    args = parser.parse_args()

    if not any([args.check, args.sync, args.freeze]):
        parser.print_help()
        return 1

    if args.check:
        success = check_sync()
        return 0 if success else 1

    if args.sync:
        success = sync_environment()
        return 0 if success else 1

    if args.freeze:
        success = freeze_constraints()
        return 0 if success else 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
